# controllables-java
A lib for unit testing which takes a "stubs" approach; an alternative to the "mocks" frameworks (which i'm not a big fan of)!

## What is it?

A new Java utility library which auto generates, what I call "controllable" versions of classes/interfaces for use in testing.  There is now, also a Utilities module, which contains some utility classes for doing "controllable" like things for testing (without actually generating a Controllable class).

## What is a "controllable"?
A controllable (i'm not putting the "" from here on in) is an implementation of a class or interface which allows the user to specify how the controlled methods behave (by setting how a call to a method will exit - e.g. by returning a given value, or by throwing a given Exception), and viewing the execution history of it (the history contains the call time, any supplied arguments, and how the method exited for each execution of the method).  If you are familiar with "Test Doubles" terminology (if you are not then i highly recommend this as a good read), then you can think of a controllable as sometinng like a programmable Stub.

## What is it useful for?
(Suprisingly) It is useful during testing.  It's great for providing implementations of objects (classes/interfaces) that your SUT (system under test) needs to use, but you otherwise wouldn't have control over how it behaves (such as a DAO interface, or an IIPCProvider).  With a controllable version one of these, you can specify how it is going to behave, without needing to work out how to make the real version of that object do what you want it to do.  Yes this is starting to sound a bit like what you might use a mocking framework for, but it isn't mocking, and doesn't have any notion of horrible "expectations". 

## What can I do with it?
There are two main things that you can do with a controllable.
1. Set how the execution of the controlled method will exit.  
  * This can be one of 3 types...
   * Normal Exit : Where you provide the value (of the correct return type) that the method will return (apart from void methods, which basically just do nothing).
   * Unchecked Exception Exit : Where you provide a particular RuntimeException which will be thrown from the method.
   * Checked Exception Exit : Where you provide a particular Exception to be thrown from the method.  This is only applicable to methods that have exceptions declared on their signature (and it will only let you suppliy appropriate types).
  * You can add multiple exits (to cover various situations that you might want to mimik), and are stored and used in a FIFO maner.  The last item that is currently in the list is never removed, and is used as the default exit value (until another exit is added - which will then become the default when it is the last exit left).
  * You can clear what exits are stored in the list (useful for overriding default behaviour from a "before test" setup method).
  * You do need to provide at least one exit for a method, otherwise a ControllableMethodException will be thrown (since we wouldn't know how or what to return from the method), so this is best done by setting default exits in a test setup method.
2. See how a controlled method has executed over time. 
  * You get a snapshot (immutable list) of the current execution history, which contains the call time, method arguments used, and exit value for each execution.  Therefore you can easily see how many times a method has been called, and if you need to, drop down into the details of all these calls.
 
## How can I use it?
The controllable classes get generated by the annotation being picked up by the annotation processor (which since java 1.6 is part of the normal java compiler process - yey no extra dependency).  So depending on you IDE (as some have better support for annotation processing than others), you may or may not (but probably will) need to do a compile (or since it will more than likely be used in test source; whatever you need to do to get the test source compiled) to get the controllable classes to be generated and picked up by the IDE.

The API has been made to be pretty self-explanitory (with extra JavaDoc where further information could be needed), but below is some examples of how it can be used.

## How do I create them?
To generate a controllable, you need to use the Controllable annoation, and put it on a class where you want the generated controllable class to be (same package).  The Controllable annotation can be used in 2 ways to generate a controllable (with option 1 probably the preferable way).  In both cases, all nonfinal methods (with an accessor matching that supplied by the annotations includedModifierFilter() value - which defaults to just public), which are available to the controlled class (whether by inhertited or not), are controlled.

1. Using the separateControllables : When setting the value of this, you are basically setting which separate classes/interfaces you want a controllable version of generate.  All the given classes will get their own controllable class generated (named the same as the class but with a "Controllable_" prefix).  The class that you annotated isn't really used at all, so it doesn't matter if it is an abstract class or not.  If you like, and for some neatness and readibility, it may be nice practice to use the annotated class as a kind of controllable factory class, and have static methods on it returning instances of the generated controllable classes (but this isn't actually needed).

  Controllables Factory (recommended) 

  ```java
Controllable(separateControllables = {ControlThis.class, ControlThat.class, ControlSomeThingElse.class})	// these could be classes and/or interfaces
public class AllMyControllables{

	public static Controllable_ControlThis getControllableControlThis(){
    	return new Controllable_ControlThis();
	}

    public static Controllable_ControlThat getControllableControlThat(){
        return new Controllable_ControlThat();
    }

   	public static Controllable_ControlSomeThingElse getControlSomeThingElse(){
    	return new Controllable_ControlSomeThingElse();
    }
}
  ```
2. Not using the separateControllables :  Put the annotation on an abstract class, and leave the value of separateControllables at its default (empty array).  When used like this, a single controllable class will be generated (named the same as the annotated class, but prefixed with "Controlable_").

  Single Controllable 

  ```java
@Controllable
public abstract class MyControllableOfControlThis extends ControlThis {
	public static Controllable_ControlThis getControllable(){
		return new Controllable_ControlThis();
	}
}

@Controllable
public abstract class MyControllableOfControlThat implements ControlThat {
	public static Controllable_ControlThat getControllable(){
		return new Controllable_ControlThat();
	}
}
  ```

## How do I use my controllable?
Once you have a controllable, below is some sample usage in a junit test.

Sample usage in a JUnit Test 

TODO

## Building the Library
It needs to be built using JDK 1.8+ (although it builds 1.7 bytecode).
